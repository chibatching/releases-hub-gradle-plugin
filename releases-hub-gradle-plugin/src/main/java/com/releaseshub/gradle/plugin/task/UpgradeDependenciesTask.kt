package com.releaseshub.gradle.plugin.task


import com.jdroid.github.PullRequest
import com.jdroid.github.RepositoryId
import com.jdroid.github.client.GitHubClient
import com.jdroid.github.service.IssueService
import com.jdroid.github.service.PullRequestService
import com.releaseshub.gradle.plugin.artifacts.Artifact
import com.releaseshub.gradle.plugin.artifacts.ArtifactsService
import com.releaseshub.gradle.plugin.common.AbstractTask
import java.io.File
import java.io.IOException

open class UpgradeDependenciesTask : AbstractTask() {

	lateinit var dependenciesFilesPaths: List<String>
	lateinit var includes: List<String>
	lateinit var excludes: List<String>
	lateinit var baseBranch: String
	lateinit var headBranch: String
	lateinit var commitMessage: String
	lateinit var pullRequestTitle: String
	var pullRequestEnabled: Boolean = false

	var gitHubUserName: String? = null
	var gitHubUserEmail: String? = null
	lateinit var gitHubRepositoryOwner: String
	lateinit var gitHubRepositoryName: String
	var gitHubWriteToken: String? = null

	init {
		description = "Upgrade dependencies"
	}

	override fun onExecute() {

		if (pullRequestEnabled) {
			require(this::gitHubRepositoryOwner.isInitialized) { "gitHubRepositoryOwner extension property is required"}
			require(this::gitHubRepositoryName.isInitialized) { "gitHubRepositoryName extension property is required"}

			gitHubWriteToken = propertyResolver.getStringProp("gitHubWriteToken")
			require(gitHubWriteToken != null) { "gitHubWriteToken property is required"}
		}

		val artifacts = mutableSetOf<Artifact>()
		val filesMap = mutableMapOf<String, List<String>>()

		dependenciesFilesPaths.forEach {
			val lines = project.rootProject.file(it).readLines()
			filesMap[it] = lines

			lines.forEach { line ->
				val artifact = DependenciesParser.extractArtifact(line)
				if (artifact != null && artifact.match(includes, excludes)) {
					artifacts.add(artifact)
				}
			}
		}

		val artifactsToUpgrade = ArtifactsService.getArtifactsToUpgrade(artifacts.toList())
		if (artifactsToUpgrade.isNotEmpty()) {

			if (pullRequestEnabled) {
				prepareGitBranch()
			}

			val upgradeResults = mutableListOf<UpgradeResult>()
			filesMap.entries.forEach {
				File(it.key).bufferedWriter().use { out ->
					it.value.forEach { line ->
						val upgradeResult = DependenciesParser.upgradeDependency(line, artifactsToUpgrade)
						if (upgradeResult.upgraded) {
							upgradeResults.add(upgradeResult)
						}
						out.write(upgradeResult.line + "\n")
					}
				}
			}

			upgradeResults.forEach {
				log(" - ${it.artifact} -> ${it.artifact?.toVersion}")
			}

			if (pullRequestEnabled) {
				val pullRequestBody = createPullRequestBody(upgradeResults)
				createPullRequest(pullRequestBody)
			}
		}
	}

	private fun prepareGitBranch() {
		gitHubUserName?.let {
			commandExecutor.execute("git config user.name $gitHubUserName")
		}
		gitHubUserEmail?.let {
			commandExecutor.execute("git config user.email $gitHubUserEmail")
		}

		commandExecutor.execute("git checkout $baseBranch")
		commandExecutor.execute("git pull")

		// Local headBranch cleanup
		commandExecutor.execute("git branch -D $headBranch", project.rootProject.projectDir, true, true)
		commandExecutor.execute("git fetch origin --prune")
		val execResult = commandExecutor.execute("git checkout $headBranch", project.rootProject.projectDir, true, true)
		if (!execResult.isSuccessful()) {
			commandExecutor.execute("git checkout -b $headBranch")
		}

		// Try to merge from baseBranch to headBranch
		commandExecutor.execute("git merge $baseBranch")
	}

	private fun createPullRequestBody(upgradeResults: List<UpgradeResult>): String {
		val builder = StringBuilder()
		builder.appendln("## Dependencies upgrades")
		upgradeResults.forEach {
			builder.appendln("#### ${it.artifact} `${it.artifact?.fromVersion}` -> `${it.artifact?.toVersion}`")
			var atLeastOneItem = false
			if (it.artifact?.releaseNotesUrl != null) {
				builder.append("* [Releases notes](${it.artifact.releaseNotesUrl})")
				atLeastOneItem = true
			}
			if (it.artifact?.sourceCodeUrl != null) {
				builder.append(if (atLeastOneItem) " | " else "* ")
				builder.append("[Source code](${it.artifact.sourceCodeUrl})")
				atLeastOneItem = true
			}
			if (it.artifact?.documentationUrl != null) {
				builder.append(if (atLeastOneItem) " | " else "* ")
				builder.append("[Documentation](${it.artifact.documentationUrl})")
				atLeastOneItem = true
			}
			if (atLeastOneItem) {
				builder.appendln()
			}
		}
		builder.appendln()
		builder.appendln("This pull request was automatically generated by **[Releases Hub Gradle Plugin](https://github.com/maxirosson/releases-hub-gradle-plugin)**")
		return builder.toString()
	}

	private fun createPullRequest(pullRequestBody: String) {
		commandExecutor.execute("git add -A")

		val execResult = commandExecutor.execute("git commit -m \"$commitMessage\"", project.rootProject.projectDir, true, true)
		when {
			execResult.isSuccessful() -> {
				commandExecutor.execute("git push origin HEAD:$headBranch")
				log("The changes were pushed to $headBranch branch.")

				val client = GitHubClient()
				client.setSerializeNulls(false)
				client.setOAuth2Token(gitHubWriteToken)

				val repositoryIdProvider = RepositoryId.create(gitHubRepositoryOwner, gitHubRepositoryName)
				val pullRequestService = PullRequestService(client)

				var pullRequest: PullRequest?
				try {
					pullRequest = pullRequestService.getPullRequest(repositoryIdProvider, IssueService.STATE_OPEN, "$gitHubRepositoryOwner:$headBranch", baseBranch)
					if (pullRequest == null) {
						pullRequest = pullRequestService.createPullRequest(repositoryIdProvider, pullRequestTitle, pullRequestBody, headBranch, baseBranch)
						log("The pull request #" + pullRequest!!.number + " was successfully created.")
					} else {
						log("The pull request #" + pullRequest.number + " already exists.")
					}
				} catch (e: IOException) {
					throw RuntimeException(e)
				}
			}
			execResult.getStandardOutput().contains("nothing to commit") -> log("Nothing new to commit.")
			else -> throw RuntimeException("Git commit command failed with exit value: " + execResult.exitValue)
		}
	}
}
