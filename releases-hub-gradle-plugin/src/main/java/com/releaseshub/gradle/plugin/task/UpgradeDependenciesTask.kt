package com.releaseshub.gradle.plugin.task

import com.jdroid.github.RepositoryId
import com.jdroid.github.client.GitHubClient
import com.jdroid.github.service.IssueService
import com.jdroid.github.service.PullRequestService
import com.releaseshub.gradle.plugin.artifacts.Artifact
import com.releaseshub.gradle.plugin.artifacts.ArtifactsService
import com.releaseshub.gradle.plugin.artifacts.api.AppServer
import com.releaseshub.gradle.plugin.common.AbstractTask
import java.io.File
import java.io.IOException

open class UpgradeDependenciesTask : AbstractTask() {

    var serverName: String? = null

    var dependenciesFilesPaths: List<String>? = null
    lateinit var includes: List<String>
    lateinit var excludes: List<String>

    var baseBranch: String? = null
    var headBranch: String? = null
    var commitMessage: String? = null
    var pullRequestTitle: String? = null
    var pullRequestEnabled: Boolean = false

    var gitHubUserName: String? = null
    var gitHubUserEmail: String? = null
    var gitHubRepositoryOwner: String? = null
    var gitHubRepositoryName: String? = null
    var gitHubWriteToken: String? = null

    init {
        description = "Upgrade dependencies"
    }

    companion object {
        private const val PULL_REQUEST_FOOTER = "This pull request was automatically generated by **[Releases Hub Gradle Plugin](https://github.com/maxirosson/releases-hub-gradle-plugin)**"
    }

    override fun onExecute() {

        getExtension().validateServerName()
        getExtension().validateDependenciesFilesPaths()

        if (pullRequestEnabled) {
            getExtension().validateBaseBranch()
            getExtension().validateHeadBranch()
            getExtension().validateCommitMessage()
            getExtension().validatePullRequestTitle()
            getExtension().validateGitHubRepositoryOwner()
            getExtension().validateGitHubRepositoryName()
            getExtension().validateGitHubWriteToken()
        }

        val artifacts = mutableSetOf<Artifact>()
        val filesMap = mutableMapOf<String, List<String>>()

        dependenciesFilesPaths!!.forEach {
            val lines = project.rootProject.file(it).readLines()
            filesMap[it] = lines

            lines.forEach { line ->
                val artifact = DependenciesParser.extractArtifact(line)
                if (artifact != null && artifact.match(includes, excludes)) {
                    artifacts.add(artifact)
                }
            }
        }

        val artifactsToUpgrade = ArtifactsService(AppServer.valueOf(serverName!!)).getArtifactsToUpgrade(artifacts.toList())
        if (artifactsToUpgrade.isNotEmpty()) {

            if (pullRequestEnabled) {
                prepareGitBranch()
            }

            val upgradeResults = mutableListOf<UpgradeResult>()
            filesMap.entries.forEach {
                File(it.key).bufferedWriter().use { out ->
                    it.value.forEach { line ->
                        val upgradeResult = DependenciesParser.upgradeDependency(line, artifactsToUpgrade)
                        if (upgradeResult.upgraded) {
                            upgradeResults.add(upgradeResult)
                        }
                        out.write(upgradeResult.line + "\n")
                    }
                }
            }

            upgradeResults.forEach {
                log(" - ${it.artifact} ${it.artifact?.fromVersion} -> ${it.artifact?.toVersion}")
            }

            if (pullRequestEnabled) {
                createPullRequest(upgradeResults)
            }
        }
    }

    private fun prepareGitBranch() {
        gitHubUserName?.let {
            commandExecutor.execute("git config user.name $gitHubUserName")
        }
        gitHubUserEmail?.let {
            commandExecutor.execute("git config user.email $gitHubUserEmail")
        }

        commandExecutor.execute("git checkout $baseBranch")
        commandExecutor.execute("git pull")

        // Local headBranch cleanup
        commandExecutor.execute("git branch -D $headBranch", project.rootProject.projectDir, true, true)
        commandExecutor.execute("git fetch origin --prune")
        val execResult = commandExecutor.execute("git checkout $headBranch", project.rootProject.projectDir, true, true)
        if (!execResult.isSuccessful()) {
            commandExecutor.execute("git checkout -b $headBranch")
        }

        // Try to merge from baseBranch to headBranch
        commandExecutor.execute("git merge $baseBranch")
    }

    private fun createPullRequestBody(upgradeResults: List<UpgradeResult>, baseBody: String? = null): String {
        val builder = StringBuilder()
        if (baseBody == null) {
            builder.appendln("## Dependencies upgrades")
        } else {
            builder.append(baseBody.replaceFirst(PULL_REQUEST_FOOTER + "\n", ""))
        }
        upgradeResults.forEach {
            builder.appendln("#### ${it.artifact} `${it.artifact?.fromVersion}` -> `${it.artifact?.toVersion}`")
            var atLeastOneItem = false
            if (it.artifact?.releaseNotesUrl != null) {
                builder.append("* [Releases notes](${it.artifact.releaseNotesUrl})")
                atLeastOneItem = true
            }
            if (it.artifact?.sourceCodeUrl != null) {
                builder.append(if (atLeastOneItem) " | " else "* ")
                builder.append("[Source code](${it.artifact.sourceCodeUrl})")
                atLeastOneItem = true
            }
            if (it.artifact?.documentationUrl != null) {
                builder.append(if (atLeastOneItem) " | " else "* ")
                builder.append("[Documentation](${it.artifact.documentationUrl})")
                atLeastOneItem = true
            }
            if (atLeastOneItem) {
                builder.appendln()
            }
        }
        builder.appendln()
        builder.appendln(PULL_REQUEST_FOOTER)
        return builder.toString()
    }

    private fun createPullRequest(upgradeResults: List<UpgradeResult>) {
        commandExecutor.execute("git add -A")

        val execResult = commandExecutor.execute("git commit -m \"$commitMessage\"", project.rootProject.projectDir, true, true)
        when {
            execResult.isSuccessful() -> {
                commandExecutor.execute("git push origin HEAD:$headBranch")
                log("The changes were pushed to $headBranch branch.")

                val client = GitHubClient()
                client.setSerializeNulls(false)
                client.setOAuth2Token(gitHubWriteToken)

                val repositoryIdProvider = RepositoryId.create(gitHubRepositoryOwner, gitHubRepositoryName)
                val pullRequestService = PullRequestService(client)

                try {
                    var pullRequest = pullRequestService.getPullRequest(repositoryIdProvider, IssueService.STATE_OPEN, "$gitHubRepositoryOwner:$headBranch", baseBranch)
                    if (pullRequest == null) {
                        val pullRequestBody = createPullRequestBody(upgradeResults)
                        pullRequest = pullRequestService.createPullRequest(repositoryIdProvider, pullRequestTitle, pullRequestBody, headBranch, baseBranch)
                        log("The pull request #" + pullRequest!!.number + " was successfully created.")
                    } else {
                        val pullRequestBody = createPullRequestBody(upgradeResults, pullRequest.body)
                        pullRequestService.editPullRequest(repositoryIdProvider, pullRequest.number, pullRequest.title, pullRequestBody, IssueService.STATE_OPEN, baseBranch)
                        log("The pull request #" + pullRequest.number + " already exists, editing it")
                    }
                } catch (e: IOException) {
                    throw RuntimeException(e)
                }
            }
            execResult.getStandardOutput().contains("nothing to commit") -> log("Nothing new to commit.")
            else -> throw RuntimeException("Git commit command failed with exit value: " + execResult.exitValue)
        }
    }
}
